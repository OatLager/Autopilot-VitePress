# Thread

::: info 문서 개요
Autopilot 애플리케이션 모듈의 특성과 요구사항에 따라 WorkQueue 또는 독립 스레드 실행 방식을 사용합니다. 이 문서는 각 방식의 개념과 차이점, 그리고 생성 시점을 설명합니다.
:::

## 1. 모듈 실행 방식

### 1.1. WorkQueue 방식

- **개념** : 미리 생성된 공용 작업 스레드(WorkQueue)에게 모듈의 작업을 위임하는 방식입니다. 여러 모듈이 하나의 '작업 대기열'을 공유하며, WorkQueue는 이 대기열에 들어온 작업들을 순서대로 처리합니다.

- **동작** : 모듈은 `ScheduledWorkItem` 클래스를 상속받고, `Run()` 함수에 주기적으로 실행할 코드를 작성합니다. `ScheduleOnInterval()` 같은 함수를 통해 WorkQueue에 작업을 등록하면, 해당 WorkQueue에서 등록된 모듈 작업 순서대로 `Run()` 함수를 호출해 모듈을 실행시켜 줍니다.

- **장점** : 여러 모듈이 하나의 스레드와 스택 메모리를 공유하므로, **RAM 사용량을 크게 절약**할 수 있습니다. 코드가 단순하고 비동기적인 이벤트 기반 처리에 유리합니다.

- **주요 사용 모듈** : 각종 센서 드라이버 등 주기적으로 실행되지만 극도의 실시간성이 필요하지 않은 모듈.

---

### 1.2. 독립 스레드 방식

- **개념** : 모듈이 자신만의 전용 스레드를 직접 생성하여 실행하는 방식입니다. 다른 모듈의 영향을 받지 않는 독립된 실행 흐름을 가집니다.

- **동작** : 모듈은 `px4_task_spawn_cmd()` 함수를 호출하여 새로운 스레드를 생성합니다. 이 스레드는 보통 `while` 루프를 포함하는 `task_main` 또는 `run` 함수를 계속해서 실행합니다.

- **장점** : 모듈별로 독립적인 우선순위를 가질 수 있고, 다른 모듈의 작업에 의해 방해받지 않으므로 **실시간성 보장에 유리**합니다. 비행 제어와 직결되는 핵심 로직에 적합합니다.

- **주요 사용 모듈** : `commander`, `navigator` 등 높은 안정적인 실행이 보장되어야 하는 핵심 모듈.

## 2. 스레드 생성 시점

### 2.1. WorkQueue 생성 시점

WorkQueue와 작업자 스레드들은 모든 모듈이 실행되기 전, **시스템 시작 초기 단계에서 단 한 번 생성**됩니다. 이는 `rcS` 스크립트에서 실행되는 모든 모듈들이 즉시 WorkQueue를 사용할 수 있도록 하기 위함입니다.

- **스레드 생성** : `rcS` 스크립트 실행 이전, 초기화 단계.

---

### 2.2. 독립 스레드 생성 시점

독립 스레드는 시스템 시작 시 한꺼번에 만들어지는 것이 아니라, **각 모듈이 `start` 명령어로 실행되는 바로 그 시점에 개별적으로 생성**됩니다.

- **스레드 생성** : `rsS` 스크립트가 각 모듈의 `start` 명령어를 실행.


## 3. 실행 방식 차이점 비교

| 항목 | 독립 스레드 방식 | WorkQueue 방식|
| :--- | :--- | :--- |
| **실행 방식** | 모듈 자신만의 고유한 스레드 생성 및 작업 수행 | 미리 생성된 공유 스레드에게 작업을 위임 |
| **자원 사용량 (RAM)** | **높음**. 각 모듈이 자신만의 스택 메모리를 차지 | **낮음**. 여러 모듈이 하나의 스택 메모리를 공유 |
| **실시간성/우선순위** | 모듈별로 독립적인 우선순위 설정 | WorkQueue의 우선순위를 공유 |
| **주요 사용처** | 실시간성이 매우 중요한 핵심 제어 모듈 | 주기적, 이벤트 기반의 보조 기능 모듈 |


## 부록
### 부록 A : WorkQueue의 메모리 절약 원리
::: details WorkQueue의 메모리 절약 원리

WorkQueue 방식이 RAM 자원을 획기적으로 절약할 수 있는 이유는 **스택(Stack) 메모리**의 사용 방식에 있습니다.

---

#### 스택 메모리란?

모든 스레드(Task)는 실행될 때 자신만의 독립적인 메모리 공간인 **스택**을 필요로 합니다. 스택에는 함수의 지역 변수, 함수 호출 정보 등이 저장되며, 스레드가 생성될 때 미리 정해진 크기(예: 2KB)만큼 통째로 할당됩니다.

---

#### 독립 스레드 방식: "모든 직원에게 개인 사무실 제공"

- **개념**: **모듈 하나당 스레드 하나**를 생성하므로, **모듈 개수만큼의 스택 메모리**가 필요합니다.
- **예시**: 3개의 모듈을 독립 스레드로 실행하면, 각 2KB씩 총 **6KB**의 스택 RAM이 소모됩니다. 각 모듈이 잠시 쉬고 있더라도 이 공간은 다른 모듈이 사용할 수 없습니다.

---

#### WorkQueue 방식: "공용 회의실 하나를 다 같이 사용"

- **개념**: **여러 모듈이 하나의 공유 스레드**를 사용하므로, **단 하나의 스택 메모리**만 필요합니다.
- **예시**: 3개의 모듈이 하나의 WorkQueue를 사용하면, 단 하나의 작업자 스레드를 위한 스택 **2KB**만 소모됩니다. 모듈들은 이 공간을 시간대별로 나눠 쓰므로 공간 효율이 극대화됩니다.

이러한 스택 공유 방식 덕분에, 수십 개의 모듈이 동작하는 PX4 시스템은 수십 KB의 귀중한 RAM을 절약할 수 있습니다. 이는 더 많은 기능을 추가하고 시스템 안정성을 높이는 데 결정적인 역할을 합니다.

---

#### 결론: 왜 두 가지 방식을 사용하는가?

PX4가 두 가지 실행 방식을 모두 사용하는 이유는 **실시간성**과 **자원 효율성**이라는 두 가지 목표를 동시에 달성하기 위함입니다. 비행 제어와 직결되는 핵심 모듈은 독립 스레드로 만들어 안정적인 실행을 보장받고, 그 외의 보조 기능 모듈들은 WorkQueue를 사용하여 제한된 임베디드 시스템의 RAM 자원을 아끼는 매우 효율적인 아키텍처입니다.

:::